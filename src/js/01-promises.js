/**
 * Створення та обробка промісу
 * - Клас Promise
 * - resolve
 * - reject
 * - then, catch, finally
 */

//* promise - це обʼєкт, який представляє результат асинхронної операції (створення промісу є синхронною операцією, а його обробка - асинхронною (мікрозадача))

// В event loop асинхронні операції починають виконуватись тільки тоді як закінчаться усі синхронні (тобто стек викликів буде пустим). У нас є дві черги для асинхронних задач: Макрозадачі (setTimeout, setInterval, addEventListener) і Мікрозадачі (promise). Макрозадачі починають виконуватись (падати в стек викликів) тільки тоді, коли черга мікрозадач буде пуста. Це означає що перед виконанням будь-якої макрозадачі спочатку повинні виконатись усі мікрозадачі які є у черзі. (Наприклад, якщо у нас одночасно виконався таймаут і проміс, то проміс буде виконано першим, бо він є мікрозадачею)

/*
Проміс має 3 стани:
- Pending - стан створення промісу, означає, що проміс поки що не виконався
- Fullfilled - проміс виконався успішно (обролюється методом .then())
- Rejected - проміс виконався неуспішно (обролюється методом .catch())

-- Також між програмістами ви можете почути термін Settled - означає, що проміс виконався (тобто, два стани: Fullfilled, Rejected)
*/

// const promise = new Promise((resolve, reject) => {
//   //* resolve - фукнція, яка переведе проміс у стан Fullfilled
//   //* reject - функція, яка переведе проміс у стан Rejected

//   const userNumber = Number(prompt('Enter your number:'));

//   if (userNumber >= 0) {
//     resolve(userNumber); // виклик цієї фукнції переведе проміс у стан фулфілд і в якості даних ми передамо число, яке ввів користувач, а обробимо ці данні в блоці then()
//   } else {
//     reject(userNumber); // виклик цієї фукнції переведе проміс у стан реджектед і в якості даних ми передамо число, яке ввів користувач, а обробимо ці данні в блоці catch()
//   }
// });

//console.log(promise); // побачимо обʼєкт промісу у стані пендінг, наголошую увагу на тому, що витягнути результат виконання промісу у синхронний код не можна!!! (можна зробити імітацію через async/await, але це розглянемо пізніше, або обробити результат промісу за допомогою методів then() та catch())

// promise
//   .then(value => {
//     console.log(`THEN BLOCK: ✅ ${value}`);
//   })
//   .catch(err => {
//     console.log(`CATCH BLOCK: ❌ ${err}`);
//   })
//   .finally(() => {
//     console.log('FINALLY: проміс завершений!');
//   });

/**
 * Ланцюги промісів
 * - декілька послідовних then
 * - then повертає проміс
 */

const promise = new Promise((res, rej) => {
  const randomValue = Math.random();
  const isPromiseFullfilled = randomValue > 0.5;
  console.log(isPromiseFullfilled);

  setTimeout(() => {
    if (isPromiseFullfilled) {
      res(randomValue);
    } else {
      rej(randomValue);
    }
  }, 1000);
});

console.log(promise);

// проміс допомагає позбутись колбек хелу і зробити імітацію послідовності (синхронності) виконання асинхронного коду
promise
  .then(value => {
    console.log(`THEN BLOCK: ✅ ${value}`);
    console.log('імітуємо запит на сервер 1...');
    setTimeout(() => console.log('Відповідь від серверу 1:', 5), 1000);
    return 5;
  })
  .then(number => {
    console.log('THEN BLOCK 2');
    console.log('Відповідь від серверу 1:', number);
    console.log('імітуємо запит на сервер 2...');
    const serverRerponse = 2;
    setTimeout(() => console.log('Відповідь від серверу 2:', serverRerponse), 2000);
    return { a: number, b: serverRerponse };
  })
  .then(({ a, b }) => {
    console.log('THEN BLOCK 3');
    console.log('Рахуємо результат...');
    // throw new Error('помилка під час запиту на сервер 3'); //! якщо викидується помилка під час обробки - вона попадає в блок catch
    setTimeout(() => console.log(`Результат відповіді від 3 серверу: ${a + b}`), 3000);
  })
  .catch(err => {
    console.log(`CATCH BLOCK: ❌ ${err}`);
    console.dir(err);
  });

/*
!callback hell

callback1(() => {
    ...
    callback2(() => {
        ..
        callback3(() => {
            ..
            callback4(() => {
                ..
                })
            })
        })
    })

*/

//! Важливо запамʼятати, що в якості значення параметру колбек фукнції then (value) приходить те, що ви передали у функцію resolve, або те, що повернув (return) попердній then в вашому ланцюгу!!!

// then потрібен не тільки для обробки успішного результату виконання асинхронного коду, а й задля імітації синхронності виконання асинхронного коду.
